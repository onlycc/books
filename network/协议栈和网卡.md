# 电信号传输TCP/IP数据

## 创建套接字

### 协议栈的内部结构

操作系统中的*网络控制软件（协议栈）*和*网络硬件（网卡）*

第一层：网络应用程序：浏览器、Web服务器、电子邮件服务器等

第二层：Socket库，包含解析器（用来向DNS服务器发出查询）

第三层：操作系统，包含协议栈（TCP协议、UDP协议、IP协议：ICMP协议和ARP协议）。

> 浏览器、邮件等一般的应用程序都是用TCP收发数据的；DNS查询等收发较短的控制数据的时候用UDP。

> ICMP协议用于告知网络包传输过程中产生的错误以及各种控制消息，ARP协议用于根据IP地址查询相应的以太网MAC地址。

第四层：网卡驱动程序，负责控制网卡硬件。

第五层：网卡，负责实际的收发操作，对网线中的信号执行发送和接收的操作。

### 套接字

协议栈内部有一块用于*存放控制信息的内存空间*，记录了用于控制通信操作的控制信息：通信对象的IP地址、端口号、操作系统的进行状态等。

> 协议栈是根据套接字中记录的控制信息来工作的。windows中可以是用netstat -ano查看套接字的内容。

#### DNS解析
```html
内存地址/IP地址=gethostbyname(...) Socket库中的解析器 <=> UDP模块 <=> IP模块 <=> DNS服务器
```
#### 浏览器通过Socket库向协议栈发出委托的一系列操作
```html
TCP模块 <==> IP模块 <==> Web服务器
```

##### 创建套接字：<描述符>=socket(<IPv4>,<TCP>...)

首先分配一个套接字所需的内存空间，然后向其写入初始状态，然后返回描述符（区分协议栈中的多个套接字的号码牌）

##### 连接：connect(<描述符>,<服务器的IP和端口号>,...) 

连接操作的第一步是在TCP模块处创建表示连接控制信息的头部。然后TCP模块把信息传递给IP模块并委托它进行发送。

> 传递给协议栈中的TCP模块，然后TCP模块会与服务器的TCP模块交换控制信息。

调用connect，协议栈将本地的套接字和服务器的套接字进行连接。连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作。

在连接节点，数据收发还没有开始，网络包中没有实际的数据，只有控制信息，这些控制信息位于网络包的开头，称为头部。（以太网和IP的控制信息，TCP的控制信息）

###### TCP三次握手

所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。在Socket编程中，客户端执行connect()时将触发三次握手。

1. 客户端创建一个包含开始数据收发操作的*控制信息的头部*，客户端就准确的找到了服务端的套接字。将控制位的SYN=1，表示连接。然后TCP模块把信息传递给IP模块并委托它进行发送。网络包就会通过网络到服务器。

2. 服务端上的IP模块将接受到的数据传递给TCP模块，然后TCP模块根据TCP头部的信息找到端口对应的套接字。找到对应的套接字之后，套接字就会写入相应的信息，把连接状态改为正在连接。 然后服务器的TCP模块返回响应，在TCP头部设置发送方和接收方的端口号以及SYN=1，ACK=1 表示已经接收到相应的网络包。

3. 网络包返回到客户端之后，确认SYN为1表示连接成功，向套接字中写入服务器的IP和端口号，设置状态表示连接完毕。然后客户端把ACK=1并发回服务器，告诉服务器刚才的响应包已经收到了。

4. 服务器收到返回包，连接操作建立完成。套接字两端连接建立起来了。

##### 发送：write(...) / 接收：接受数据长度=read(...) 

应用程序在进行收发消息时要提供描述符。

协议栈并不是一收到数据就马上发送出去，会将数据存放在内部的发送缓存区中，等待下一段数据。协议栈内部有一个计时器，一定时间后会把网络包发送出去。

```html
MTU， 最大传输单元: 一个网络包的最大长度，以太网一般是1500字节。包含了头部的总长度。
MTU = 报头/起始帧分界符 + MAC头部 + IP头部 + TCP头部 + 数据 + FCS（帧校验序列）

MSS，最大分段大小: 除去头部之后，一个网络包能容纳的TCP数据的最大长度。
```

HTTP头部+消息体， 如果长度超过网络包所能容纳的数据量。发送缓冲区的数据会被以MSS长度为单位进行拆分。

###### 使用ACK号确认网络包已经收到
整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。

在实际的通信中，序号并不是从1 开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从1 开始，通信过程就会非常容易预测，受到攻击。因此需要在开始收发数据之前将初始值告知通信对象。

TCP数据收发是双向的，在设置SYN=1时还要设置Seq=X设置序号的初始值。服务端也需要计算一个序号，在连接过程中互相告知对方自己的序号初始值，服务端Seq=Y。

```html
SYN为1表示发起连接
连接操作：
1. client =(SYN=1, Seq=X)=> server
2. client <=(SYN=1, Seq=Y, ACK=X+1) = server
3. client =(ACK=Y+1, Seq=Z)=> server

收发操作：
4. client =(序号+数据)=> server
5. client <=(ACK号)= server

6. server =(序号+数据)=> client
7. client =(ACK号)=> server

收到数据后再返回ACK号，TCP采用这种方式确认对方是否收到了数据，在对方确认之前发生过来的包都会保存在发送缓冲区，如果对方没有返回ACK，就会重新发送这些包。

有了这个机制网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。
```

###### 接收HTTP响应消息

浏览器在委托协议栈发送消息之后，调用read程序来响应消息。协议栈会检查收到的数据块和TCP头部的内容，判断数据是否有丢失，没有返回ACK号，返回协议栈将数据块暂存到接收缓冲区，将数据块按照顺序连接起来还原出原始数据，交给应用程序。

##### 断开：close(<描述符>)，删除套接字

完成数据发送的一方会发起断开过程，调用Socket库的close程序。

```html
1. 服务器的协议栈会生成包含断开信息的TCP头部：FIN=1

2. 客户端收到服务器发来的FIN=1的TCP头部时，客户端的协议栈会将自己的套接字标记进入断开状态。客户端向服务端返回ACK号。

3. 客户端应用程序会调用close来结束数据收发操作。生成FIN=1的TCP包，发送给服务器。

4. 服务器返回ACK号。

客户端和服务器的通信就全部结束了。
```
