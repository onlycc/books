# 网络协议

## 不同的网络协议
URL: Uniform Resource Locator，统一资源定位符
URI: Uniform Resource Indentifier，统一资源标识符

访问时使用的协议类型：

- HTTP协议（Hypertext Tranfer Protocol 超文本传送协议） 访问Web服务器
- FTP协议 下载和上传文件
- file 读取客户端计算机本地文件
- mailto 发送电子邮件

### 浏览器访问一个链接的步骤

#### 第一步： 对URL进行解析，从而生成发送到Web服务器的请求消息。
浏览器使用HTTP协议来访问Web服务器

http: + // + web服务器名 + / + 目录名 + / ... + 文件名

- 省略文件名：大多数情况是访问index.html或者default.htm之类的文件名
- 省略路径/ ：访问根目录下的默认文件

> 一个请求小子中只能写1个URI，如果需要获取多个文件，必须对每个文件单独发送1条请求。

HTTP协议定义了客户端和服务器之间交互的消息内容和步骤。请求消息中包含的内容是：对什么 + 进行怎样的操作 两个部分。

对什么：URI（访问目标统称为URI）

进行怎样的操作：方法

- HTTP1.1: GET/POST/HEAD/DELETE/PUT/OPTIONS/CONNECT/TRACE
- HTTP1.0: GET/POST/HEAD/DELETE/PUT

Web服务器收到消息后会对其中的内容进行解析，通过对URI和方法来判断对什么进行怎样的操作，然后将结果放进响应消息中。
HTTP状态码
-1xx 告知请求的处理监督和情况
-2xx 成功
-3xx 表示需要进一步操作
-4xx 客户端错误
-5xx 服务器错误


HTTP消息有严格的格式规定，浏览器会按照规定的格式来生成请求消息。

请求消息
```html
<方法><空格><URI><空格><HTTP版本>
<字段名>:<字段值>
...
...
<空行>
<消息体>
```

响应消息
```html
<HTTP版本><空格><状态码><空格><响应短语>
<字段名>:<字段值>
...
...
<空行>
<消息体>
```

#### 第二步: 向DNS服务器查询Web服务器的IP地址

浏览器具备能够解析网址并生成HTTP消息，但是不具备将消息发送到网络中的功能，这个发送消息的功能委托给操作系统来实现。在委托操作系统发送消息时，必须要提供IP地址。

在网络中所有的设备都会被分配一个地址IP地址，通过IP地址我们可以判断出访问对象服务器的位置，从而发送消息到服务器。
- 路由器：一种对包进行转发的设备。（内置了集线器的功能）
- 集线器：一种对包进行转发的设备，分为中继式集线器和交换式集线器。


互联网和公司内部的局域网都是基于TCP/IP的思路来设计的。集线器连接起来的所有设备都属于同一个子网。子网通过路由器连接起来就形成了一个网络。

1. 发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上。
2. 路由器会根据消息的目的地进行判断下一个路由器的位置，然后将消息发送到下一个路由器。不断重复，最终消息被传送到了目的地址。

IPv4 地址是遗传32bit的数字，按照8bit为一组（一个字节）分成4组，分别用十进制表示，然后用圆点隔开。IP地址是分配给了按照了网络的硬件，如果一台设备安装了多个网络硬件就有多个IP地址。

网络好和主机号连起来总共是32bit，两部分的具体结构不是固定的。
在组件网络时，用户可以自行决定它们之间的分配关系。需要附加信息来表示IP地址的内部结构（子网掩码）。
子网掩码中的为1的部分表示网络号，为0的部分表示主机号。

> IP地址的主机号： 全0 表示整个子网；全1 表示向子网所有设备发送包，即广播。

* 使用IP地址长度固定32bit，使用域名可能很长，长度不固定，会增加路由器的负担。

##### DNS域名解析
DNS: Domain Name System，域名服务系统，将服务器和IP地址进行关联时DNS最常见的用法。

解析器实际上是一段程度，它包含在操作系统的Socket库中。库就是一堆通用程序组件的集合。

> Socket库是同于调用网络功能的程序组件集合,Socket是网络开发中的一种标准库。

浏览器会使用Socket库中的解析器，调用解析器后，解析器会向DNS服务器发送查询消息，然后DNS服务器会返回响应消息，包含查询到的IP地址，解析器会读取IP地址，将其写入浏览器的内存地址中。

浏览器向Web服务器发送消息时，只要从内存地址中读取IP地址，并将它与HTTP请求消息一起交给操作系统就可以了。

向DNS发送消息时也需要知道DNS服务器的IP地址。这个IP地址是作为TCP/IP的一个设置项目事先设置好的，不需要去查询。


##### DNS工作原理

来自客户端的查询消息包含：域名、Class（识别网络信息，互联易只有：IN）、记录类型（A，Address的缩写：域名对应的是IP地址；MX：域名对应的是邮件服务器）
记录类型还有其他的：根据IP地址反查询域名的PTR类型，查询域名相关别名的CNAME类型，查询DNS服务器IP地址的NS类型，查询域名属性信息的SOA类型。

> 只要注册了A类型的记录，都可以作为服务器的域名来使用

DNS服务器会从域名与IP地址的对照表中查询相应的记录，并返回IP地址。


DNS服务器将信息分布保存在多台DNS服务器中，这些DNS服务器会相互接力配合，从而查找出要查询的信息。DNS服务器中的所有信息都是按照域名以分层次的结构来保存的。
www.example.com
越靠右边的位置表示的层级越高。每个域都是作为一个整体来处理的，一个域的信息是作为一个整体存在DNS服务器中的。一台DNS服务器可以管理多个域的信息。

#### 查找要访问的Web服务器的信息归那一台DNS服务器

将下级域的DNS服务器的IP地址注册到上一级的DNS服务器中，这样我们就可以通过上级的DNS服务器查询出下级DNS服务器的IP地址，就可以向下级DNS服务器发送查询请求了。

|-根域
  - com
  - cn
    - example

根域DNS服务器保存在互联网中的所有的DNS服务器。分配给根域DNS服务器的IP地址在全世界只有13个，而且这些地址几乎不会发生变化。

DNS查询步骤：
1. 客户端访问最近的一台DNS服务器；
2. 由于最近的DNS服务器中没有存在查询的域名的信息，我们需要从顶层开始向下查找。
3. 根域服务器判断属于com域，返回com域的DNS服务器的IP地址；
4. com域服务器返回example.com域的DNS服务器的IP地址；
5. 客户端知道了Web服务器的IP地址

DNS服务器有一个缓存的功能，查询的域名在存在缓存中，可以直接返回响应。缓存有有效期。

#### 第三步：委托协议栈发送消息

通过DNS服务器查询到IP地址后，可以委托操作系统内部的协议栈向目标IP发送消息。需要使用Socket库中的程序组件。发送的是数字信息。

> 向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用Socket库中的程序组件。

进行收发数据操作之前，双方需要先建立管道。管道两端的数据的出入口（套接字）。
我们需要先创建套接字，然后再将套接字连接起来形成管道。

> 服务器程序一般会再启动后就创建好套接字并等待客户端来连接管道。管道的连接是右客户端发起的，但是在断开时可以由客户端和服务端任何一方发起。管道断开后，套接字也会被删除。

##### 收发数据 操作系统中的协议栈来执行
1. 创建套接字 
  创建阶段：调用Socket库中的socket程序组件，执行创建套接字操作，返回一个描述符识别某个特定的套接字。

2. 将管道连接到服务端的套接字上 
  连接阶段：需要委托协议栈将客户端创建的套接字与服务器那边的套接字链接起来。使用Socket库中的connect的程序组件，需要描述符，服务器IP和端口号3个参数。
  
  端口号：是用来让通信的另一方能够识别出套接字的机制。
  服务器上所使用的端口号是根据应用的种类事先规定好的。 Web是80，邮件是25端口。
  > 描述符：应用程序用来识别套接字的机制。IP和端口：客户端和服务器之间用来识别对方套接字的机制。

3. 收发数据
  通信阶段：通过Socket库委托协议栈，使用write这个程序组件。
  在内存中准备要发送的数据：浏览器生成的HTTP请求消息。
  调用write时：指导描述符和发送的数据。
  协议栈将数据发送到福服务器。

  接受消息：是Socket库中的read程序组件委托协议栈来完成的。
  调用read时，指定存放接受到的响应消息的内存地址（接受缓冲区，位于应用程序的内存空间）

4. 断开管道并删除套接字 
  断开阶段：调用Socket库的close程序组件。

在每个阶段，Socket库中的程序组件都会被调用来执行相关的数据收发操作。
