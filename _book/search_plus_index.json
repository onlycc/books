{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. 知识库1. 知识库 # 执行脚本 提交文档 bash build.sh By onlycc            updated 2020-12-04 21:44:29 "},"network/network.html":{"url":"network/network.html","title":"网络","keywords":"","body":"1. 网络1.1. 推荐书籍1. 网络 1.1. 推荐书籍 《计算机网络》 《图解HTTP》 《网络是怎样连接的》 By onlycc            updated 2020-12-04 20:10:15 "},"network/浏览器生成消息.html":{"url":"network/浏览器生成消息.html","title":"浏览器生成消息","keywords":"","body":"1. 网络协议1.1. 不同的网络协议1.1.1. 浏览器访问一个链接的步骤1. 网络协议 1.1. 不同的网络协议 URL: Uniform Resource Locator，统一资源定位符 URI: Uniform Resource Indentifier，统一资源标识符 访问时使用的协议类型： HTTP协议（Hypertext Tranfer Protocol 超文本传送协议） 访问Web服务器 FTP协议 下载和上传文件 file 读取客户端计算机本地文件 mailto 发送电子邮件 1.1.1. 浏览器访问一个链接的步骤 第一步： 对URL进行解析，从而生成发送到Web服务器的请求消息。 浏览器使用HTTP协议来访问Web服务器 http: + // + web服务器名 + / + 目录名 + / ... + 文件名 省略文件名：大多数情况是访问index.html或者default.htm之类的文件名 省略路径/ ：访问根目录下的默认文件 一个请求中只能写1个URI，如果需要获取多个文件，必须对每个文件单独发送1条请求。 HTTP协议定义了客户端和服务器之间交互的消息内容和步骤。请求消息中包含的内容是：对什么 + 进行怎样的操作 两个部分。 对什么：URI（访问目标统称为URI） 进行怎样的操作：方法 HTTP1.1: GET/POST/HEAD/DELETE/PUT/OPTIONS/CONNECT/TRACE HTTP1.0: GET/POST/HEAD/DELETE/PUT Web服务器收到消息后会对其中的内容进行解析，通过对URI和方法来判断对什么进行怎样的操作，然后将结果放进响应消息中。 HTTP状态码 -1xx 告知请求的处理监督和情况 -2xx 成功 -3xx 表示需要进一步操作 -4xx 客户端错误 -5xx 服务器错误 HTTP消息有严格的格式规定，浏览器会按照规定的格式来生成请求消息。 请求消息 : ... ... 响应消息 : ... ... 第二步: 向DNS服务器查询Web服务器的IP地址 浏览器具备能够解析网址并生成HTTP消息，但是不具备将消息发送到网络中的功能，这个发送消息的功能委托给操作系统来实现。在委托操作系统发送消息时，必须要提供IP地址。 在网络中所有的设备都会被分配一个地址IP地址，通过IP地址我们可以判断出访问对象服务器的位置，从而发送消息到服务器。 路由器：一种对包进行转发的设备。（内置了集线器的功能） 集线器：一种对包进行转发的设备，分为中继式集线器和交换式集线器。 互联网和公司内部的局域网都是基于TCP/IP的思路来设计的。集线器连接起来的所有设备都属于同一个子网。子网通过路由器连接起来就形成了一个网络。 发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上。 路由器会根据消息的目的地进行判断下一个路由器的位置，然后将消息发送到下一个路由器。不断重复，最终消息被传送到了目的地址。 IPv4 地址是一个32bit的数字，按照8bit为一组（一个字节）分成4组，分别用十进制表示，然后用圆点隔开。IP地址是分配给了按照了网络的硬件，如果一台设备安装了多个网络硬件就有多个IP地址。 网络号和主机号连起来总共是32bit，两部分的具体结构不是固定的。在组件网络时，用户可以自行决定它们之间的分配关系。需要附加信息来表示IP地址的内部结构（子网掩码）。 子网掩码中的为1的部分表示网络号，为0的部分表示主机号。 IP地址的主机号： 全0 表示整个子网；全1 表示向子网所有设备发送包，即广播。 使用IP地址长度固定32bit，使用域名可能很长，长度不固定，会增加路由器的负担。 DNS域名解析 DNS: Domain Name System，域名服务系统，将服务器和IP地址进行关联是DNS最常见的用法。 解析器实际上是一段程序，它包含在操作系统的Socket库中。库就是一堆通用程序组件的集合。 Socket库是同于调用网络功能的程序组件集合,Socket是网络开发中的一种标准库。 Socket库是加州大学伯克利分校开发的UNIX系操作系统BSD中开发的C语言库，互联网中所使用的大多数功能都是基于Socket库开发的。 浏览器会使用Socket库中的解析器，调用解析器后，解析器会向DNS服务器发送查询消息，然后DNS服务器会返回响应消息，包含查询到的IP地址，解析器会读取IP地址，将其写入浏览器的内存地址中。 浏览器向Web服务器发送消息时，只要从内存地址中读取IP地址，并将它与HTTP请求消息一起交给操作系统就可以了。 向DNS发送消息时也需要知道DNS服务器的IP地址。这个IP地址是作为TCP/IP的一个设置项目事先设置好的，不需要去查询。 DNS工作原理 来自客户端的查询消息包含：域名、Class（识别网络信息，互联易只有：IN）、记录类型（A，Address的缩写：域名对应的是IP地址；MX：域名对应的是邮件服务器） 记录类型还有其他的：根据IP地址反查询域名的PTR类型，查询域名相关别名的CNAME类型，查询DNS服务器IP地址的NS类型，查询域名属性信息的SOA类型。 只要注册了A类型的记录，都可以作为服务器的域名来使用 DNS服务器会从域名与IP地址的对照表中查询相应的记录，并返回IP地址。 DNS服务器将信息分布保存在多台DNS服务器中，这些DNS服务器会相互接力配合，从而查找出要查询的信息。DNS服务器中的所有信息都是按照域名以分层次的结构来保存的。 www.example.com 越靠右边的位置表示的层级越高。每个域都是作为一个整体来处理的，一个域的信息是作为一个整体存在DNS服务器中的。一台DNS服务器可以管理多个域的信息。 查找要访问的Web服务器的信息归那一台DNS服务器 将下级域的DNS服务器的IP地址注册到上一级的DNS服务器中，这样我们就可以通过上级的DNS服务器查询出下级DNS服务器的IP地址，就可以向下级DNS服务器发送查询请求了。 |-.根域 - com - example - www 根域DNS服务器保存在互联网中的所有的DNS服务器。分配给根域DNS服务器的IP地址在全世界只有13个，而且这些地址几乎不会发生变化。 DNS查询步骤： 客户端访问最近的一台DNS服务器； 由于最近的DNS服务器中没有存在查询的域名的信息，我们需要从顶层开始向下查找。 根域服务器判断属于com域，返回com域的DNS服务器的IP地址； com域服务器返回example.com域的DNS服务器的IP地址； ...客户端知道了Web服务器的IP地址 DNS服务器有一个缓存的功能，查询的域名在存在缓存中，可以直接返回响应。缓存有有效期。 第三步：委托协议栈发送消息 通过DNS服务器查询到IP地址后，可以委托操作系统内部的协议栈向目标IP发送消息。需要使用Socket库中的程序组件。发送的是数字信息。 向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用Socket库中的程序组件。 进行收发数据操作之前，双方需要先建立管道。管道两端的数据的出入口（套接字）。我们需要先创建套接字，然后再将套接字连接起来形成管道。 服务器程序一般会在启动后就创建好套接字并等待客户端来连接管道。管道的连接是由客户端发起的，但是在断开时可以由客户端和服务端任何一方发起。管道断开后，套接字也会被删除。 收发数据 操作系统中的协议栈来执行 创建套接字 创建阶段：调用Socket库中的socket程序组件，执行创建套接字操作，返回一个描述符识别某个特定的套接字。 将管道连接到服务端的套接字上 连接阶段：需要委托协议栈将客户端创建的套接字与服务器那边的套接字链接起来。使用Socket库中的connect的程序组件，需要描述符，服务器IP和端口号3个参数。 端口号：是用来让通信的另一方能够识别出套接字的机制。服务器上所使用的端口号是根据应用的种类事先规定好的。 Web是80，邮件是25端口。 描述符：应用程序用来识别套接字的机制。 IP和端口：客户端和服务器之间用来识别对方套接字的机制。 收发数据 通信阶段：通过Socket库委托协议栈，使用write这个程序组件。 在内存中准备要发送的数据：浏览器生成的HTTP请求消息。 调用write时：指导描述符和发送的数据。协议栈将数据发送到服务器。 接收消息：是Socket库中的read程序组件委托协议栈来完成的。调用read时，指定存放接收到的响应消息的内存地址（接受缓冲区，位于应用程序的内存空间） 断开管道并删除套接字 断开阶段：调用Socket库的close程序组件。 在每个阶段，Socket库中的程序组件都会被调用来执行相关的数据收发操作。 By onlycc            updated 2020-12-12 20:45:25 "},"network/协议栈和网卡.html":{"url":"network/协议栈和网卡.html","title":"协议栈和网卡","keywords":"","body":"1. 电信号传输TCP/IP数据1.1. 创建套接字1.1.1. 协议栈的内部结构1.1.2. 套接字1. 电信号传输TCP/IP数据 1.1. 创建套接字 1.1.1. 协议栈的内部结构 操作系统中的网络控制软件（协议栈）和网络硬件（网卡） 第一层：网络应用程序：浏览器、Web服务器、电子邮件服务器等 第二层：Socket库，包含解析器（用来向DNS服务器发出查询） 第三层：操作系统，包含协议栈（TCP协议、UDP协议、IP协议：ICMP协议和ARP协议）。 浏览器、邮件等一般的应用程序都是用TCP收发数据的；DNS查询等收发较短的控制数据的时候用UDP。 ICMP协议用于告知网络包传输过程中产生的错误以及各种控制消息，ARP协议用于根据IP地址查询相应的以太网MAC地址。 第四层：网卡驱动程序，负责控制网卡硬件。 第五层：网卡，负责实际的收发操作，对网线中的信号执行发送和接收的操作。 1.1.2. 套接字 协议栈内部有一块用于存放控制信息的内存空间，记录了用于控制通信操作的控制信息：通信对象的IP地址、端口号、操作系统的进行状态等。 协议栈是根据套接字中记录的控制信息来工作的。windows中可以是用netstat -ano查看套接字的内容。 DNS解析 内存地址/IP地址=gethostbyname(...) Socket库中的解析器 UDP模块 IP模块 DNS服务器 浏览器通过Socket库向协议栈发出委托的一系列操作 TCP模块 IP模块 Web服务器 创建套接字：=socket(,...) 首先分配一个套接字所需的内存空间，然后向其写入初始状态，然后返回描述符（区分协议栈中的多个套接字的号码牌） 连接：connect(,,...) 连接操作的第一步是在TCP模块处创建表示连接控制信息的头部。然后TCP模块把信息传递给IP模块并委托它进行发送。 传递给协议栈中的TCP模块，然后TCP模块会与服务器的TCP模块交换控制信息。 调用connect，协议栈将本地的套接字和服务器的套接字进行连接。连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作。 在连接节点，数据收发还没有开始，网络包中没有实际的数据，只有控制信息，这些控制信息位于网络包的开头，称为头部。（以太网和IP的控制信息，TCP的控制信息） TCP三次握手 所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。在Socket编程中，客户端执行connect()时将触发三次握手。 客户端创建一个包含开始数据收发操作的控制信息的头部，客户端就准确的找到了服务端的套接字。将控制位的SYN=1，表示连接。然后TCP模块把信息传递给IP模块并委托它进行发送。网络包就会通过网络到服务器。 服务端上的IP模块将接受到的数据传递给TCP模块，然后TCP模块根据TCP头部的信息找到端口对应的套接字。找到对应的套接字之后，套接字就会写入相应的信息，把连接状态改为正在连接。 然后服务器的TCP模块返回响应，在TCP头部设置发送方和接收方的端口号以及SYN=1，ACK=1 表示已经接收到相应的网络包。 网络包返回到客户端之后，确认SYN为1表示连接成功，向套接字中写入服务器的IP和端口号，设置状态表示连接完毕。然后客户端把ACK=1并发回服务器，告诉服务器刚才的响应包已经收到了。 服务器收到返回包，连接操作建立完成。套接字两端连接建立起来了。 发送：write(...) / 接收：接受数据长度=read(...) 应用程序在进行收发消息时要提供描述符。 协议栈并不是一收到数据就马上发送出去，会将数据存放在内部的发送缓存区中，等待下一段数据。协议栈内部有一个计时器，一定时间后会把网络包发送出去。 MTU， 最大传输单元: 一个网络包的最大长度，以太网一般是1500字节。包含了头部的总长度。 MTU = 报头/起始帧分界符 + MAC头部 + IP头部 + TCP头部 + 数据 + FCS（帧校验序列） MSS，最大分段大小: 除去头部之后，一个网络包能容纳的TCP数据的最大长度。 HTTP头部+消息体， 如果长度超过网络包所能容纳的数据量。发送缓冲区的数据会被以MSS长度为单位进行拆分。 使用ACK号确认网络包已经收到 整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。 在实际的通信中，序号并不是从1 开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从1 开始，通信过程就会非常容易预测，受到攻击。因此需要在开始收发数据之前将初始值告知通信对象。 TCP数据收发是双向的，在设置SYN=1时还要设置Seq=X设置序号的初始值。服务端也需要计算一个序号，在连接过程中互相告知对方自己的序号初始值，服务端Seq=Y。 SYN为1表示发起连接 连接操作： 1. client =(SYN=1, Seq=X)=> server 2. client server 收发操作： 4. client =(序号+数据)=> server 5. client client 7. client =(ACK号)=> server 收到数据后再返回ACK号，TCP采用这种方式确认对方是否收到了数据，在对方确认之前发生过来的包都会保存在发送缓冲区，如果对方没有返回ACK，就会重新发送这些包。 有了这个机制网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。 接收HTTP响应消息 浏览器在委托协议栈发送消息之后，调用read程序来响应消息。协议栈会检查收到的数据块和TCP头部的内容，判断数据是否有丢失，没有返回ACK号，返回协议栈将数据块暂存到接收缓冲区，将数据块按照顺序连接起来还原出原始数据，交给应用程序。 断开：close()，删除套接字 完成数据发送的一方会发起断开过程，调用Socket库的close程序。 1. 服务器的协议栈会生成包含断开信息的TCP头部：FIN=1 2. 客户端收到服务器发来的FIN=1的TCP头部时，客户端的协议栈会将自己的套接字标记进入断开状态。客户端向服务端返回ACK号。 3. 客户端应用程序会调用close来结束数据收发操作。生成FIN=1的TCP包，发送给服务器。 4. 服务器返回ACK号。 客户端和服务器的通信就全部结束了。 By onlycc            updated 2020-12-13 16:11:19 "},"js/js.html":{"url":"js/js.html","title":"Javascript","keywords":"","body":"1. Javascript1.1. 推荐书籍1. Javascript 1.1. 推荐书籍 《你不知道的JS》上中下 《Javascript权威指南》 By onlycc            updated 2020-12-04 20:11:56 "}}