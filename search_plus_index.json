{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. 知识库1. 知识库 # 执行脚本 提交文档 bash build.sh By onlycc            updated 2020-12-04 21:44:29 "},"basic/leetcode.html":{"url":"basic/leetcode.html","title":"编码","keywords":"","body":"leetcode学习方法 提升刷题效率的方式： 先掌握基本数据结构和算法； 推荐阅读《大话数据结构》、《啊哈算法》、《图解算法》、《算法导论》等。 写代码不要使用IDE，直接在leetcode上写； 熟练使用各种基本函数，训练自己的写代码速度。 刷题时要按照同类型的刷题，分模块逐个击破。 可以按照一本书，边学习算法思路，学习例题，然后再leetcode上找相关的题进行练习。参考书籍：《程序员面试金典》、《剑指Offer》 每一道题都要精益求精，学习其他人的优秀代码。磨练自己的代码。 参考别人代码学习思路，然后代码完全要自己写出来，并且过一段时间再做还能做出来才是正在的掌握了。 刷题时要总结，记录关键点和易错点，写下关键思路。 每天睡前复习5分钟。 有意识的提高自己的写代码的速度，打字速度。可以通过参加leetcode周赛训练。 培养自己一次性写成无bug代码，思路程序设计。 15分钟没有任何思路，不要死磕，可以参考其他人的思路进行学习。 按照书籍进行学习和刷题，然后通过HOT100和精选200来模拟冲刺。 重点做中等难度的题， HOT100难的也需要掌握。 By onlycc            updated 2020-12-13 20:41:26 "},"basic/算法学习.html":{"url":"basic/算法学习.html","title":"算法学习","keywords":"","body":"1 year+: 搭建网站、作品集展示自己的经验；多做项目； 3-12 months: 简历/心仪清单；做题。 1-3 months: 加深重要概念的理解；记录常见错误； 重点： 手写代码，在纸上写好代码之后，再写到计算机上进行验证。 回顾项目经历准备小故事；模拟面试训练。 不要死记硬背答案。大声说出解题思路。 写代码放慢节奏，有条不紊，多做测试，考虑周全。 写代码注意可维护性，不要缺少面向对象设计。 在处理复杂问题时，边写代码边测试。 修改bug前找出问题根因。 面对困难不要轻言放弃。 为什么要加入某公司？ 碰到最棘手的Bug？（深入令人印象深刻的答案） 列举要点：“使用A实现了B，从而达到了C效果”。 2-4个重要项目：简明扼要，使用什么语言什么技术。 编程语言：JavaScript(非常熟练)， Python(熟练)， Go/Java/C++(有过使用经验) 行为面试: 项目，浓缩成关键字 项目：最难的部分；有什么收获；最有意思的部分；最难解的Bug；最享受的过程；与团队成员的冲突。 你有哪些缺点？ 项目中最难处理的问题是什么？ 你想问面试官什么问题？（对公司和团队最调研） 建议： 力求具体，切记自大； 省略细枝末节； 回答条理清晰； 技术准备： 尽量独自解题：解题时考虑空间和时间效率。 在纸上编写算法；在纸上测试代码；写一般用例，基本用例，错误用例。 将代码输入计算机。整理一份清单，罗列出自己犯得所有错误！ 模拟面试 直接实现一种数据结构和算法（链表，二叉树，栈，队列等） 熟记2M幂表： 27 128 28 256 210 1024 1K 216 65,536 64K 220 1,048,576 一百万 1MB 230 1,073,741,824 十亿 1GB 232 4GB 240 1TB 技术题： 提问消除疑义； 设计一种算法；考虑：空间和时间复杂度，考虑大数据的情况。 先写伪代码；多用数据结构，定义数据结构，面向对象设计。 写代码不紧不慢；极端用例：0，负数，null，最大值，最小值。 测试写到的代码，修正错误； 五种解法： 举例法 列举一些具体的例子，找是否有一般规律 模式匹配法 将现有问题和相似问题做类比，是否可以通过修改相关问题的解法来解决 简化推广法 先简化问题，然后基于这个进行推广；调整简化版问题的解决方案，让它适合更加复杂的版本 简单构造法 从最基本的情况解决问题，记下正确结果，n=1,n=2....n 找到规律 数据结构头脑风暴法 快速过一遍数据结构的列表，逐一尝试各种数据结构。 好代码： 正确+高效+简洁+易读+可维护性 多用数据结构 适当重用代码 模块化 灵活、健壮（灵活使用变量，不要把值写死） 错误检查（对输入进行处理） By onlycc            updated 2020-12-15 21:02:57 "},"network/network.html":{"url":"network/network.html","title":"网络","keywords":"","body":"1. 网络1.1. 推荐书籍1. 网络 1.1. 推荐书籍 《计算机网络》 《图解HTTP》 《网络是怎样连接的》 By onlycc            updated 2020-12-04 20:10:15 "},"network/浏览器生成消息.html":{"url":"network/浏览器生成消息.html","title":"浏览器生成消息","keywords":"","body":"1. 网络协议1.1. 不同的网络协议1.1.1. 浏览器访问一个链接的步骤1. 网络协议 1.1. 不同的网络协议 URL: Uniform Resource Locator，统一资源定位符 URI: Uniform Resource Indentifier，统一资源标识符 访问时使用的协议类型： HTTP协议（Hypertext Tranfer Protocol 超文本传送协议） 访问Web服务器 FTP协议 下载和上传文件 file 读取客户端计算机本地文件 mailto 发送电子邮件 1.1.1. 浏览器访问一个链接的步骤 第一步： 对URL进行解析，从而生成发送到Web服务器的请求消息。 浏览器使用HTTP协议来访问Web服务器 http: + // + web服务器名 + / + 目录名 + / ... + 文件名 省略文件名：大多数情况是访问index.html或者default.htm之类的文件名 省略路径/ ：访问根目录下的默认文件 一个请求中只能写1个URI，如果需要获取多个文件，必须对每个文件单独发送1条请求。 HTTP协议定义了客户端和服务器之间交互的消息内容和步骤。请求消息中包含的内容是：对什么 + 进行怎样的操作 两个部分。 对什么：URI（访问目标统称为URI） 进行怎样的操作：方法 HTTP1.1: GET/POST/HEAD/DELETE/PUT/OPTIONS/CONNECT/TRACE HTTP1.0: GET/POST/HEAD/DELETE/PUT Web服务器收到消息后会对其中的内容进行解析，通过对URI和方法来判断对什么进行怎样的操作，然后将结果放进响应消息中。 HTTP状态码 -1xx 告知请求的处理监督和情况 -2xx 成功 -3xx 表示需要进一步操作 -4xx 客户端错误 -5xx 服务器错误 HTTP消息有严格的格式规定，浏览器会按照规定的格式来生成请求消息。 请求消息 : ... ... 响应消息 : ... ... 第二步: 向DNS服务器查询Web服务器的IP地址 浏览器具备能够解析网址并生成HTTP消息，但是不具备将消息发送到网络中的功能，这个发送消息的功能委托给操作系统来实现。在委托操作系统发送消息时，必须要提供IP地址。 在网络中所有的设备都会被分配一个地址IP地址，通过IP地址我们可以判断出访问对象服务器的位置，从而发送消息到服务器。 路由器：一种对包进行转发的设备。（内置了集线器的功能） 集线器：一种对包进行转发的设备，分为中继式集线器和交换式集线器。 互联网和公司内部的局域网都是基于TCP/IP的思路来设计的。集线器连接起来的所有设备都属于同一个子网。子网通过路由器连接起来就形成了一个网络。 发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上。 路由器会根据消息的目的地进行判断下一个路由器的位置，然后将消息发送到下一个路由器。不断重复，最终消息被传送到了目的地址。 IPv4 地址是一个32bit的数字，按照8bit为一组（一个字节）分成4组，分别用十进制表示，然后用圆点隔开。IP地址是分配给了按照了网络的硬件，如果一台设备安装了多个网络硬件就有多个IP地址。 网络号和主机号连起来总共是32bit，两部分的具体结构不是固定的。在组件网络时，用户可以自行决定它们之间的分配关系。需要附加信息来表示IP地址的内部结构（子网掩码）。 子网掩码中的为1的部分表示网络号，为0的部分表示主机号。 IP地址的主机号： 全0 表示整个子网；全1 表示向子网所有设备发送包，即广播。 使用IP地址长度固定32bit，使用域名可能很长，长度不固定，会增加路由器的负担。 DNS域名解析 DNS: Domain Name System，域名服务系统，将服务器和IP地址进行关联是DNS最常见的用法。 解析器实际上是一段程序，它包含在操作系统的Socket库中。库就是一堆通用程序组件的集合。 Socket库是同于调用网络功能的程序组件集合,Socket是网络开发中的一种标准库。 Socket库是加州大学伯克利分校开发的UNIX系操作系统BSD中开发的C语言库，互联网中所使用的大多数功能都是基于Socket库开发的。 浏览器会使用Socket库中的解析器，调用解析器后，解析器会向DNS服务器发送查询消息，然后DNS服务器会返回响应消息，包含查询到的IP地址，解析器会读取IP地址，将其写入浏览器的内存地址中。 浏览器向Web服务器发送消息时，只要从内存地址中读取IP地址，并将它与HTTP请求消息一起交给操作系统就可以了。 向DNS发送消息时也需要知道DNS服务器的IP地址。这个IP地址是作为TCP/IP的一个设置项目事先设置好的，不需要去查询。 DNS工作原理 来自客户端的查询消息包含：域名、Class（识别网络信息，互联易只有：IN）、记录类型（A，Address的缩写：域名对应的是IP地址；MX：域名对应的是邮件服务器） 记录类型还有其他的：根据IP地址反查询域名的PTR类型，查询域名相关别名的CNAME类型，查询DNS服务器IP地址的NS类型，查询域名属性信息的SOA类型。 只要注册了A类型的记录，都可以作为服务器的域名来使用 DNS服务器会从域名与IP地址的对照表中查询相应的记录，并返回IP地址。 DNS服务器将信息分布保存在多台DNS服务器中，这些DNS服务器会相互接力配合，从而查找出要查询的信息。DNS服务器中的所有信息都是按照域名以分层次的结构来保存的。 www.example.com 越靠右边的位置表示的层级越高。每个域都是作为一个整体来处理的，一个域的信息是作为一个整体存在DNS服务器中的。一台DNS服务器可以管理多个域的信息。 查找要访问的Web服务器的信息归那一台DNS服务器 将下级域的DNS服务器的IP地址注册到上一级的DNS服务器中，这样我们就可以通过上级的DNS服务器查询出下级DNS服务器的IP地址，就可以向下级DNS服务器发送查询请求了。 |-.根域 - com - example - www 根域DNS服务器保存在互联网中的所有的DNS服务器。分配给根域DNS服务器的IP地址在全世界只有13个，而且这些地址几乎不会发生变化。 DNS查询步骤： 客户端访问最近的一台DNS服务器； 由于最近的DNS服务器中没有存在查询的域名的信息，我们需要从顶层开始向下查找。 根域服务器判断属于com域，返回com域的DNS服务器的IP地址； com域服务器返回example.com域的DNS服务器的IP地址； ...客户端知道了Web服务器的IP地址 DNS服务器有一个缓存的功能，查询的域名在存在缓存中，可以直接返回响应。缓存有有效期。 第三步：委托协议栈发送消息 通过DNS服务器查询到IP地址后，可以委托操作系统内部的协议栈向目标IP发送消息。需要使用Socket库中的程序组件。发送的是数字信息。 向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用Socket库中的程序组件。 进行收发数据操作之前，双方需要先建立管道。管道两端的数据的出入口（套接字）。我们需要先创建套接字，然后再将套接字连接起来形成管道。 服务器程序一般会在启动后就创建好套接字并等待客户端来连接管道。管道的连接是由客户端发起的，但是在断开时可以由客户端和服务端任何一方发起。管道断开后，套接字也会被删除。 收发数据 操作系统中的协议栈来执行 创建套接字 创建阶段：调用Socket库中的socket程序组件，执行创建套接字操作，返回一个描述符识别某个特定的套接字。 将管道连接到服务端的套接字上 连接阶段：需要委托协议栈将客户端创建的套接字与服务器那边的套接字链接起来。使用Socket库中的connect的程序组件，需要描述符，服务器IP和端口号3个参数。 端口号：是用来让通信的另一方能够识别出套接字的机制。服务器上所使用的端口号是根据应用的种类事先规定好的。 Web是80，邮件是25端口。 描述符：应用程序用来识别套接字的机制。 IP和端口：客户端和服务器之间用来识别对方套接字的机制。 收发数据 通信阶段：通过Socket库委托协议栈，使用write这个程序组件。 在内存中准备要发送的数据：浏览器生成的HTTP请求消息。 调用write时：指导描述符和发送的数据。协议栈将数据发送到服务器。 接收消息：是Socket库中的read程序组件委托协议栈来完成的。调用read时，指定存放接收到的响应消息的内存地址（接受缓冲区，位于应用程序的内存空间） 断开管道并删除套接字 断开阶段：调用Socket库的close程序组件。 在每个阶段，Socket库中的程序组件都会被调用来执行相关的数据收发操作。 By onlycc            updated 2020-12-12 20:45:25 "},"network/协议栈和网卡.html":{"url":"network/协议栈和网卡.html","title":"协议栈和网卡","keywords":"","body":"1. 电信号传输TCP/IP数据1.1. 创建套接字1.1.1. 协议栈的内部结构1.1.2. 套接字1. 电信号传输TCP/IP数据 1.1. 创建套接字 1.1.1. 协议栈的内部结构 操作系统中的网络控制软件（协议栈）和网络硬件（网卡） 第一层：网络应用程序：浏览器、Web服务器、电子邮件服务器等 第二层：Socket库，包含解析器（用来向DNS服务器发出查询） 第三层：操作系统，包含协议栈（TCP协议、UDP协议、IP协议：ICMP协议和ARP协议）。 浏览器、邮件等一般的应用程序都是用TCP收发数据的；DNS查询等收发较短的控制数据的时候用UDP。 ICMP协议用于告知网络包传输过程中产生的错误以及各种控制消息，ARP协议用于根据IP地址查询相应的以太网MAC地址。 第四层：网卡驱动程序，负责控制网卡硬件。 第五层：网卡，负责实际的收发操作，对网线中的信号执行发送和接收的操作。 1.1.2. 套接字 协议栈内部有一块用于存放控制信息的内存空间，记录了用于控制通信操作的控制信息：通信对象的IP地址、端口号、操作系统的进行状态等。 协议栈是根据套接字中记录的控制信息来工作的。windows中可以是用netstat -ano查看套接字的内容。 DNS解析 内存地址/IP地址=gethostbyname(...) Socket库中的解析器 UDP模块 IP模块 DNS服务器 浏览器通过Socket库向协议栈发出委托的一系列操作 TCP模块 IP模块 Web服务器 创建套接字：=socket(,...) 首先分配一个套接字所需的内存空间，然后向其写入初始状态，然后返回描述符（区分协议栈中的多个套接字的号码牌） 连接：connect(,,...) 连接操作的第一步是在TCP模块处创建表示连接控制信息的头部。然后TCP模块把信息传递给IP模块并委托它进行发送。 传递给协议栈中的TCP模块，然后TCP模块会与服务器的TCP模块交换控制信息。 调用connect，协议栈将本地的套接字和服务器的套接字进行连接。连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作。 在连接节点，数据收发还没有开始，网络包中没有实际的数据，只有控制信息，这些控制信息位于网络包的开头，称为头部。（以太网和IP的控制信息，TCP的控制信息） TCP三次握手 所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。在Socket编程中，客户端执行connect()时将触发三次握手。 客户端创建一个包含开始数据收发操作的控制信息的头部，客户端就准确的找到了服务端的套接字。将控制位的SYN=1，表示连接。然后TCP模块把信息传递给IP模块并委托它进行发送。网络包就会通过网络到服务器。 服务端上的IP模块将接受到的数据传递给TCP模块，然后TCP模块根据TCP头部的信息找到端口对应的套接字。找到对应的套接字之后，套接字就会写入相应的信息，把连接状态改为正在连接。 然后服务器的TCP模块返回响应，在TCP头部设置发送方和接收方的端口号以及SYN=1，ACK=1 表示已经接收到相应的网络包。 网络包返回到客户端之后，确认SYN为1表示连接成功，向套接字中写入服务器的IP和端口号，设置状态表示连接完毕。然后客户端把ACK=1并发回服务器，告诉服务器刚才的响应包已经收到了。 服务器收到返回包，连接操作建立完成。套接字两端连接建立起来了。 发送：write(...) / 接收：接受数据长度=read(...) 应用程序在进行收发消息时要提供描述符。 协议栈并不是一收到数据就马上发送出去，会将数据存放在内部的发送缓存区中，等待下一段数据。协议栈内部有一个计时器，一定时间后会把网络包发送出去。 MTU， 最大传输单元: 一个网络包的最大长度，以太网一般是1500字节。包含了头部的总长度。 MTU = 报头/起始帧分界符 + MAC头部 + IP头部 + TCP头部 + 数据 + FCS（帧校验序列） MSS，最大分段大小: 除去头部之后，一个网络包能容纳的TCP数据的最大长度。 HTTP头部+消息体， 如果长度超过网络包所能容纳的数据量。发送缓冲区的数据会被以MSS长度为单位进行拆分。 使用ACK号确认网络包已经收到 整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。 在实际的通信中，序号并不是从1 开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从1 开始，通信过程就会非常容易预测，受到攻击。因此需要在开始收发数据之前将初始值告知通信对象。 TCP数据收发是双向的，在设置SYN=1时还要设置Seq=X设置序号的初始值。服务端也需要计算一个序号，在连接过程中互相告知对方自己的序号初始值，服务端Seq=Y。 SYN为1表示发起连接 连接操作： 1. client =(SYN=1, Seq=X)=> server 2. client server 收发操作： 4. client =(序号+数据)=> server 5. client client 7. client =(ACK号)=> server 收到数据后再返回ACK号，TCP采用这种方式确认对方是否收到了数据，在对方确认之前发生过来的包都会保存在发送缓冲区，如果对方没有返回ACK，就会重新发送这些包。 有了这个机制网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。 接收HTTP响应消息 浏览器在委托协议栈发送消息之后，调用read程序来响应消息。协议栈会检查收到的数据块和TCP头部的内容，判断数据是否有丢失，没有返回ACK号，返回协议栈将数据块暂存到接收缓冲区，将数据块按照顺序连接起来还原出原始数据，交给应用程序。 断开：close()，删除套接字 完成数据发送的一方会发起断开过程，调用Socket库的close程序。 1. 服务器的协议栈会生成包含断开信息的TCP头部：FIN=1 2. 客户端收到服务器发来的FIN=1的TCP头部时，客户端的协议栈会将自己的套接字标记进入断开状态。客户端向服务端返回ACK号。 3. 客户端应用程序会调用close来结束数据收发操作。生成FIN=1的TCP包，发送给服务器。 4. 服务器返回ACK号。 客户端和服务器的通信就全部结束了。 By onlycc            updated 2020-12-13 16:11:19 "},"network/IP与以太网的包的收发.html":{"url":"network/IP与以太网的包的收发.html","title":"IP与以太网的包的收发","keywords":"","body":"1. IP与以太网的包的收发1.1. IP模块1.1.1. 通过ARP查询目标路由器的MAC地址1.1.2. 以太网1.1.3. 网卡发送信号1.2. UDP协议的收发操作1.2.1. 音频和视频数据1.2.2. 信号在网线和集线器中传输1. IP与以太网的包的收发 包的基本结构 = 头部（控制信息） + 数据 发送方的网络设备会负责创建包：生成含有正确控制信息的头部+要发送的数据。 包被发送到最近的网络转发设备，转发设备根据头部信息判断接下来要发往哪里。 ... 经过多个转发设备的接力之后，包到达了接收方的网络设备。 路由器根据目标地址判断下一个路由器的位置。路由器中有一张IP协议的表，可以根据这张表以及IP头部中记录的目的信息查出接下来要发往哪一个路由器的MAC地址，改写MAC头部。 MAC头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息。 集线器在子网中将网络包传输下一个路由。集线器是根据以太网协议工作的设备。 IP模块负责添加两个头部： MAC头部（包含MAC地址，用于以太网协议，子网中的以太网协议将包传输到下一个转发设备） IP头部（包含IP地址，用于IP协议，IP协议根据目标地址判断下一个IP转发设备的位置） 网卡的网络包有01组成的数字信息，网卡将数字信息转换为电信号或光信号，通过网线或光纤发送出去。 1.1. IP模块 IP模块接受TCP模块的委托负责包的收发工作，它会生成IP头部并附加在TCP头部前面。 IP地址是从TCP模块拿到的，TCP是从应用程序拿到的。 路由器使用路由表判断下一个路由器的位置：查询路由表 route print。 1.1.1. 通过ARP查询目标路由器的MAC地址 ARP: Address Resolution Protocol 地址解析协议 ARP利用广播对所有设备提问，这个IP地址是谁的，把MAC地址告诉我。将查询的结果放在ARP缓存中, 过几分钟会被删除。 arp -a 1.1.2. 以太网 以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术。本质是一根网线。 现在的是使用交互式集线器，信号只会流到指定的MAC地址的设备，不会到达其他设备。 1.1.3. 网卡发送信号 网卡通电之后需要进行初始化，需要网卡驱动程度对硬件进行初始化操作，然后硬件才能进入可以使用的状态。 网卡的ROM： 保存全世界唯一的MAC地址，生产网卡时候写入的。由网卡驱动程序读取并分配给MAC模块。 网卡驱动从IP模块获取包，将其复制到网卡内的缓冲区，向MAC模块发送发包命令。 MAC模块把包从缓冲区取出，在开头加上报头和起始帧分界符，在末尾加上检测错误的帧校验序列。让0和1分别对应特定的电压和电流。 网卡的MAC模块生成通用信号，然后由PHY(MAU)模块转换为卡在网线中传输的格式，并通过网线发送出去。 1.2. UDP协议的收发操作 数据短，一个包就能装下，未送达就重发。如果对方回复数据当作接收确认。UDP的最大数据长度为65507字节，需要让IP模块使用分片功能拆分之后再传输。 UDP不需要建立和端口连接的步骤，只要从应用程序获取的数据，在前面加上UDP头部，再交给IP进行发送即可。 遇到错误和丢包一概不管，UDP只是单纯的发送包。 1.2.1. 音频和视频数据 音频和视频数据中缺少了某些包并不会产生严重的问题，只是会产生一些失真或者卡顿而已，一般都是可以接受的。在这些无需重发数据，或者重发了也没什么意义的情况下，使用UDP 发送数据的效率会更高。 1.2.2. 信号在网线和集线器中传输 集线器和交换机 每个包都是独立传输的。 局域网是用的网线是双绞线，双绞线是两根信号线纠缠在一起，为了抑制噪声。 集线器将信号发送给所有连接在它上面的线路。 交换机端口的MAC模块不具有MAC地址。 交换机根据MAC地址表查找MAC地址，然后将信号发送到相应的端口。 交换机的全双工模式可以同时发送和接收信号。 路由器 路由器根据“IP地址”判断转发目标。路由器会忽略主机号，只匹配网络号。 路由器的端口都具有MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。 通过路由器转发的网络包，其接收方MAC地址为路由器端口的MAC地址。路由器会根据MAC头部后方的IP头部中的内容进行包的转发操作。 路由表中子网掩码为0.0.0.0 的记录表示“默认路由”。 路由器也会使用ARP来查询下一个转发目标的MAC地址。 IP对以太网的委只是将包传输到下一个路由器就行了，当包到达下一个路由器后，下一个路由器又重新委托以太网将包传输到再下一个路由器。 IP本身不负责包的传输，而是委托各种通信技术将包传输到下一个路由器。 地址 固定地址的分配。A公司和B公司的网络是独立的，地址出现重复就无关紧要了。 规定某些地址是用于内网，地址叫私有地址，原来的固定的地址叫作公网地址。 私有地址，在内网中可以用作私有地址的范围: 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 如果公司内网需要和互联网连接的时候，公司内网分成两部分： 一部分是对互联网开放的服务器； 另一部分是公司的内部设备。 其中对互联网开放的服务器分配共有地址，可以和互联网直接通信。内网部分分配私有地址，内网中的设备不能和互联网直接收发网络包，而是通过一种特别的机制进行连接，地址转换。 路由器的功能：地址转换 在转发网络包时对IP头部中的IP地址和端口号进行改写。 内网访问互联网 首先，TCP连接操作的第一个包被转发到互联网时，将发送方IP地址从私有地址改写成公有地址（地址转换设备的互联网接入端口的地址），端口号也需要进行改写，地址转换设备会随机选择一个空闲的端口。 （跳板机？） 在对外只能使用一个公有地址的情况下，可以用不同的端口号来区别内网中的不同终端。 互联网访问内网 从内网访问互联网，即使私网地址和端口号没有保存在对应表中也是可以进行正常转发的。端口号可以随机分配一个空闲的端口既可。 但是互联网访问公司内网，在对应表中没有记录就无法正常转发。放置非法入侵的效果。 By onlycc            updated 2020-12-13 20:39:36 "},"network/接入网.html":{"url":"network/接入网.html","title":"接入网、防火墙、代理和服务器概念","keywords":"","body":"1. 接入网2. 防火墙的结构和原理3. 负载均衡4. 代理5. 内容分发服务 CDN5.1. 通过重定向服务器分配访问目标6. 服务器6.1. 服务器和客户端的区别6.2. 服务器接收操作：6.3. 将请求的URI转换为实际的文件名6.4. 浏览器接收响应消息并显示内容1. 接入网 接入网：连接互联网与家庭、公司网络的通信线路。家用的接入网有ADSL,FTTH,CATV,ISDN,电话线等；公司则还有可能使用专线。 家庭和公司的内网是通过接入网连接到网络运营商的。 互联网可以理解为家庭、公司网络的放大版。 但是他们之间也有不同之处：转发设备之间的距离和路由维护方式不同。 家庭或公司的转发设备之间的距离几十米到几百米，可以延长以太网线就可以到达相邻的转发设备。 互联网的实体是由多个运营商网络相互连接组成的。ADSL,FTTH等接入网是与用户签约的运营商设备相连，这些设备称为POP（接入点）。 ADSL ADSL：Asymmetric Digital Subscriber Line，不对称数字用户线。它是一种利用架设在电线杆上的金属电话线来进行高速通信的技术，它的上行方向（用户到互联网）和下行方向（互联网到用户）的通信速率是不对称的。 互联网接入路由器会在网络包前面加上MAC 头部、PPPoE 头部、PPP 头部总共3 种头部， 然后发送给ADSL Modem（PPPoE 方式下）。 电话线传入的信号是语音信号和ADSL信号混合在一起的，通过分离器进行分离。分离掉ADSL使用的高频信号。 FTTH：Fiber To The Home，光纤到户。 光纤 将数字信号转成电信号，电信号转换成光信号。利用光敏元件，根据光的亮度产生不同的电压（光亮产生高电压，光暗产生低电压）。 用户认证和配置下发 ADSL,FTTH接入网到达运营商的BAS（进化型的路由器），都需要先输入用户名和密码，登录之后才能访问互联网。 BAS使用PPPoE（由传统电话拨号上网上使用的PPP协议发展来的）的方式来实现登录操作的。PPPoE是将PPP消息装入以太网包进行传输的方式。 ADSL和FTTH接入方式也是需要为计算机分配公有地址才能上网。 网络包通过接入网之后，到达运营商POP的路由器。 NOC是运营商的核心设备，从POP传来的网络包都会集中到这里，并从这里被转发到离目的地更近的POP，或者是转发到其他的运营商。 经过几次转发之后，网络包就到达了Web服务器所在的POP的路由器，然后从这里被继续转发到Web服务器。 POP和NOC遍布全国各地，它们各自的规模有大有小，但看起来跟公司里的机房没什么太大区别，都是位于一幢建筑物中的，其中的路由器或者通过线路直接连接，或者通过交换机进行连接，这些和公司以及家庭网络都是相同的。 互联网中不能单纯采用最短路由，而是需要一种能够阻止某些来源的网络包的机制，互联网的路由交换机制就具有这样的功能。 运营商就可以只将路由信息提供给那些交了费的运营商，那些没交费的运营商也就无法将网络包发送过来了。 2. 防火墙的结构和原理 防火墙：只允许发往特定服务器中的特定应用程序的包可以通过，屏蔽其他的包。 防火墙可分为包过滤、应用层网关、电路层网关等几种方式。主流的是采用包过滤方式。 如何设置包过滤的规则 网络包的头部包含了用于控制通信操作的控制信息。 根据接收方和发送方地址判断包的流向，并设置是允许还是阻止。 通过端口号限定应用程序，如果要允许应用程序的可以访问，把应用程序的端口号设置到防火墙中并允许通过。 通过控制位判断连接方向 Web使用的TCP协议是双向收发网络包的，因此如果单纯地阻止从Web 服务器发往互联网的包，则从互联网访问Web 服务器的操作也会受到影响而无法进行。 TCP控制位中SYN=1/ACK=0就表示TCP连接的第一个包，就可以阻止Web服务器发往互联网。 ACK 用于通知发送方数据已经正确接收 对阻止的包进行记录对于路由器来说负担也比较大，因此才出现了专用的硬件和软件。如果规则不复杂，也不需要记录日志，那么用内置包过滤功能的普通路由器来充当防火墙也是可以的。 防火墙无法抵御的攻击 假设Web服务器在收到含有特定数据的包时会引起宕机。但是防火墙只关心包的起点和终点，因此即便包中含有特定数据，防火墙也无法发现，于是包就被放了。 这个问题的根源在于Web服务器程序的Bug，因此修复Bug防止宕机就是其中一种方法。这类Bug中，危险性较高的会作为安全漏洞公布出来，开发者会很快发布修复了Bug的新版本，因此持续关注安全漏洞信息并更新软件的版本是非常重要的。 另一种方法就是在防火墙之外部署用来检查包的内容并阻止有害包的设备或软件。 3. 负载均衡 当服务器的访问量上升时，增加服务器线路的带宽是有效的，但是并不是网络变快了就可以解决所有问题。高速线路会传输大量的网络包，这会导致服务器的性能跟不上。 在这种情况下，使用多台服务器来分担负载的方法更有效。这种架构统称为分布式架构。 方法1: 轮询，通过这种方式可以将访问平均分配给所有的服务器。 DNS服务器来分配，则每次查询时DNS服务器都会按顺序返回不同的IP 地址。 存在的问题： 如果有一台服务器挂了，DNS还是会返回这台服务器的IP。 有些页面是动态生成的，操作跨页面，访问期间服务器发生了变化会导致操作无法进行。 方法二：负载均衡器 使用负载均衡器的IP代替Web服务器的IP地址注册到DNS服务器上。负载均衡器来判断将请求转发到哪一台Web服务器上。 根据Web服务器的负载来判断，避免负载集中在某一台服务器上。 判断请求质之间是否有相关性，让请求一直保持一个地址。 方法三：缓存服务器 将整个系统按功能分为不同的服务器：Web服务器，数据库服务器。 缓存服务器是一台通过代理机制对数据进行缓存的服务器。代理介于Web服务器和客户端之间，具有对Web服务器访问进行中转的功能。可以将Web服务器返回的数据保存在磁盘中，并且代替Web服务器将磁盘中的数据返回给客户端。 缓存服务器需要和负载均衡器一样代替Web服务器被注册到DNS服务器中。 客户端发来请求，缓存服务器会检查请求消息是否在缓存中： 客户端 ===> 缓存服务器 ===> Web服务器 *未命中缓存* 1. 缓存服务器在HTTP头部字段中添加一个Via字段，表示这个消息经过缓存服务器转发，将消息转发给Web服务器。 2. 缓存中没有数据：没有If-Modified-Since字段/或Web服务器端数据发生变化时，直接返回页面数据。 3. 将内存保存到缓存中，并记录保存时间，缓存服务器转发给客户端响应内容，在响应头中添加Via字段。 *命中缓存* 1. 缓存服务器检查是否有缓存，有缓存，添加一个If-Modified-Since头部字段，并将请求转发给Web服务器，询问Web服务器用户的请求数据是否发生了变化。 2. Web服务器会根据If-Modified-Since的值与服务器上的数据的最后更新时间进行比较，如果数据没有变化，返回一个没有发生变化的响应消息（304 Not Modified）。（Web服务器只是查询了数据的最后更新时间，没有返回页面数据，负担小，响应消息也短） 3. 缓存服务器就把缓存的数据直接返回给客户端。 4. 如果数据更新了，Web服务器会返回最新的数据，缓存服务器会把数据保存到缓存中，发送给客户端。 4. 代理 代理（Proxy）本来的意思并不是“转发”消息，而是先把消息收下来，然后“伪装”成原始客户端向Web服务器发出访问请求。 正向代理 Forwad proxy：放在客户端一侧的代理。 使用正向代理需要在浏览器中进行设置 目的：缓存；实现防火墙，防止来自互联网的非法入侵。 阻止互联网和公司内网之间的所有包，导致内网无法访问外网。可以使用代理，接收来自客户端的请求消息，然后转发到互联网中。就可以利用代理的缓存，之前访问过的数据可以从代理服务器获得。 可以禁止员工访问危险的网站或者和工作无关的网站。无代理是URI值包含文件名、目录名，有代理时是完整的网址。 反向代理 Reverse proxy: 将请求消息中的URI中的目录名和Web服务器进行关联，使得代理能够转发一般的不包含完整网址的请求消息。 透明代理 Transparent proxy: 查看请求消息的包头部，获取接收方的IP地址。集合了正向和反向代理的优点。 将透明代理放在请求消息从浏览器传输到Web服务器的路径中，当消息经过时进行拦截。 5. 内容分发服务 CDN 缓存服务器放在服务端，可以减轻Web服务器的负载，但是无法减少互联网的流量。 如果再客户端部署缓存服务器，就可以不受或少受拥塞点的影响，让网络流量更加稳定，特别是当访问内容中含有大量的图片或视频效果更加明显。 Web运营者和网络运营商签约，将自己控制的缓存服务器放在客户端的运营商处。 一些专门从事相关 服务的厂商CDSP他们部署缓存服务器，租借给Web服务运营者，这种服务称为内容分发服务。 只要Web服务器与缓存服务器建立关联，那么当客户端访问Web服务器时，实际上就是在访问CDSP的缓存服务器了。 5.1. 通过重定向服务器分配访问目标 HTTP的头部字段Location，将Web服务器访问引导到另一台服务器上的操作称为重定向。 重定向服务器收集来自各个路由器的路由信息，并根据这些信息找到最近的缓存服务器，然后将缓存服务器的地址放在Location字段中返回响应。（会增大消息的交互次数） 内容分发服务采用的缓存服务器就具备这样的功能:Web服务器在原始数据发生更新时，立即通知缓存服务器，使得缓存服务器上的数据一直保持最新状态。 6. 服务器 6.1. 服务器和客户端的区别 服务器可以分为很多的种类，硬件和操作系统与客户端的有所不同。但是在网络相关的部分：网卡、协议栈、Socket库等功能和客户端并无二致。 服务器可以同时和多个客户端进行通信。服务器的操作系统具有多任务、多线程功能，可以同时运行多个程序。 服务器结构： 等待连接模块：创建套接字，进入等待连接的暂停状态。 负载和客户端通信模块：每一次有新的客户端发起连接，都会启动一个新的客户端通信模块。或者事先启动几个客户端通信模块，从空闲的模块中挑选一个来处理。 等待连接模块 1. 创建套接字：=socket(,...) 2. 将套接字设置为等待连接状态，bind(,...), listen()；接受连接=accept(...) // 协议栈采用了这种创建套接字的新副本，并让客户端连接到这个新副本上的方法。使用客户端IP，端口，服务端IP，端口来确定某个套接字。 使用描述符来指代套接字的原因如下： （1）等待连接的套接字中没有客户端IP 地址和端口号 （2）使用描述符这一种信息比较简单 客户端通信模块 3. 收发数据: read/write 4. 断开管道并删除套接字：close 6.2. 服务器接收操作： 网卡的MAC模块将网络包从信号还原为数字信息，校验FCS(帧校验序列)并存入缓冲区。检查MAC头部确认接收方的MAC地址。 网卡需要通过中断将网络包到达的事件通知给CPU。 CPU就会暂停当前的工作，并切换到网卡的任务。 网卡驱动开始工作，从网卡缓冲区读包，根据MAC头部的以太类型字段判断协议种类，调用负责该协议的软件（TCP/IP协议栈）。 IP模块先工作，协议栈的IP模块会检查IP头部： （1） 判断是不是发给自己的； （2） 判断网络包是否经过分片； （3） 将包转交给TCP模块或UDP模块。 如果收到的是发起连接的包，则TCP 模块会: （1） 确认TCP头部的控制位SYN； （2） 检查接收方端口号； （3） 为相应的等待连接套接字复制一个新的副本； （4） 记录发送方IP 地址和端口号等信息。 收到数据包时，TCP 模块会 （1） 根据收到的包的发送方IP 地址、发送方端口号、接收方IP 地址、接收方端口号找到相对应的套接字； （2） 将数据块拼合起来并保存在接收缓冲区中； （3） 向客户端返回ACK。 6.3. 将请求的URI转换为实际的文件名 URI中的路径如果完全按照磁盘的路径，意味着整个磁盘的内容都全部暴露了，很危险。需要一种特殊的机制：URI写的是一个虚拟目录结构下的路径名。 先查询虚拟目录与实际目录的对应关系，将URI转换成实际的文件名。 6.4. 浏览器接收响应消息并显示内容 通过响应的数据类型判断其中的内容： Content-Type头部字段判断数据类型（MIME 多用途因特网邮件扩充 规格定义的），检查Content-Encoding；还需要结合其他信息综合判断数据类型：扩展名，数据内容的格式等。 By onlycc            updated 2020-12-15 21:09:16 "},"network/请求传输总结.html":{"url":"network/请求传输总结.html","title":"请求传输总结","keywords":"","body":"1. 总结1. 总结 用户输入网址； 浏览器解析网址，生成HTTP消息并转发给Socket库； HTTP消息 浏览器会使用Socket库中的解析器，向DNS服务器查询的域名的IP地址； Socket库将收到的HTTP消息作为数据转交给协议栈； TCP按照网络包的长度对数据进行拆分，在每一个包前面加上TCP头部并转交给IP; TCP + HTTP数据块 IP在TCP包前面加上IP头部，然后查询MAC地址并加上MAC头部，然后将包转交给网卡驱动； Web服务器的IP地址，最近的路由器的MAC地址； MAC + IP + TCP + HTTP数据块 网卡驱动收到IP发来的包，将其转交给网卡并发出发送指令； 网卡检查以太网的可发送状态，将包转换成电信号通过双绞线发送出去； 信号通过双绞线到达集线器； 集线器将信号广播到所有端口，这样信号便到达了交换机； 交换机根据收到的包的接收方MAC地址查询自身的地址表找到输出端口，并将包转发到输出端口； MAC + IP + TCP + HTTP数据块 互联网接入路由器根据收到的包的接收方IP地址查询自身的路由表找到输出端口，将包转发到输出端口； 互联网接入路由器输出到互联网的包带有PPPoE头部和PPP头部； BAS的MAC地址 MAC + PPPoE + PPP + IP + TCP + HTTP数据块 ADSL Modem将收到的包拆分成ATM信元； ADSL Modem将拆分后的ATM信元转换成电信号通过电话线发送出去； ADSL Modem发送的信号经过电线杆上的电话线到达电话局的DSLAM（局端多路Modem）； DSLAM将收到的电信号还原成ATM信元并发送给BAS； BAS将ATM信元还原成网络包，根据接收方IP地址进行转发； BAS转发的包被加上了L2TP头部并通过隧道； 网络包到达位于隧道出口的隧道路由器，L2TP头部和PPP头部被丢弃，通过互联网流向Web服务器； 服务器端的局域网中有防火墙，对进入的包进行检查，判断是否允许通过； 缓存服务器或Web服务器的MAC地址 Web服务器前面如果有缓存服务器，会拦截通过防护墙的包。如果用户请求的页面已经缓存在服务器上，则代替服务器向用户返回页面数据； 如果请求的页面没有被缓存，缓存服务器会将请求转发给Web服务器； Web服务器收到包后，网卡和网卡驱动会接收这个包并转交给协议栈； 协议栈依次检查IP头部和TCP头部，如果没有问题就取出HTTP消息的数据块并进行组装； HTTP消息被恢复成原始形态，然后通过Socket库转发给Web服务器； HTTP消息 Web服务器分析HTTP消息的内容，并根据请求内容将读取的数据返回给客户端； 请求的上下文：User-Agent 指明客户端的类型信息，服务器可以据此对资源的表述做抉择。 By onlycc            updated 2020-12-15 21:03:12 "},"js/js.html":{"url":"js/js.html","title":"Javascript","keywords":"","body":"1. Javascript1.1. 推荐书籍1. Javascript 1.1. 推荐书籍 《你不知道的JS》上中下 《Javascript权威指南》 By onlycc            updated 2020-12-04 20:11:56 "}}